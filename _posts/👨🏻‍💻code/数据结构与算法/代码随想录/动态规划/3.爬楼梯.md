---
title: 3.爬楼梯
date: '2022-07-05 17:35'
categories:
  - "\U0001F468\U0001F3FB‍\U0001F4BBcode"
  - 数据结构与算法
  - 代码随想录
  - 动态规划
index_img: 'https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202207051328142.jpg'
banner_img: 'https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202207051328142.jpg'
tags:
  - 动态规划
---

文章简介：LeetCode  题解——70. 爬楼梯
<!-- more -->

# 1 爬楼梯

[力扣题目链接](https://leetcode.cn/problems/climbing-stairs/)

假设你正在爬楼梯。需要 n 阶你才能到达楼顶。

每次你可以爬 1 或 2 个台阶。**你有多少种不同的方法**可以爬到楼顶呢？

注意：给定 n 是一个正整数。

示例 1：

-   输入： 2
-   输出： 2
-   解释： 有两种方法可以爬到楼顶。
    -   1 阶 + 1 阶
    -   2 阶

示例 2：

-   输入： 3
-   输出： 3
-   解释： 有三种方法可以爬到楼顶。
    -   1 阶 + 1 阶 + 1 阶
    -   1 阶 + 2 阶
    -   2 阶 + 1 阶

# 2 思路
第三层楼梯的状态可以由第二层楼梯 和 到第一层楼梯状态推导出来，那么就可以想到动态规划了。
	爬到第一层楼梯有一种方法，爬到二层楼梯有两种方法。
	第一层楼梯再跨两步就到第三层 ，第二层楼梯再跨一步就到第三层。
	dp[3] = dp[2] + dp[1] = 2+1 =3

动归五部曲：
1.  确定dp数组以及下标的含义
dp[i]： 爬到第i层楼梯，有dp[i]种方法
2.  确定递推公式
首先是dp[i - 1]，上i-1层楼梯，有dp[i - 1]种方法，那么再一步跳一个台阶不就是dp[i]了么。
还有就是dp[i - 2]，上i-2层楼梯，有dp[i - 2]种方法，那么再一步跳两个台阶不就是dp[i]了么
dp[i] = dp[i - 1] + dp[i - 2] 。
3. dp数组如何初始化
不考虑dp[0]，dp[1] = 1， dp[2] = 2
>dp[0]没有意义，i从3 开始递推
4.  确定遍历顺序
从递推公式dp[i] = dp[i - 1] + dp[i - 2];中可以看出，遍历顺序一定是从前向后遍历的
5.  举推导dp数组
举例当n为5的时候，dp table（dp数组）应该是这样的
![70.爬楼梯](https://img-blog.csdnimg.cn/20210105202546299.png)
>本质就是斐波那契数列，就是没有讨论dp[0] 的情况

#面试
有的题解是把dp[0]初始化为1，然后遍历的时候i从2开始遍历，这样是可以解题的，然后强行解释一波dp[0]应该等于1的含义。
一个严谨的思考过程，应该是初始化dp[1] = 1，dp[2] = 2，然后i从3开始遍历，
这个可以是面试的一个小问题，考察候选人对dp[i]定义的理解程度。

# 3 代码
优化一下空间复杂度
```cpp
class Solution {
public:
    int climbStairs(int n) {
        if (n <= 1) return n;
        int dp[3];
        dp[1] = 1;
        dp[2] = 2;
        for (int i = 3; i <= n; i++){
            int sum = dp[2] + dp [1];
            dp[2] = sum;
            dp[1] = dp[2]; 
        }
        return dp[2];

    }
};
```
# 4 加强版爬楼梯
这道题目还可以继续深化，就是一步一个台阶，两个台阶，三个台阶，直到 m个台阶，有多少种方法爬到n阶楼顶。
```cpp
class Solution {
public:
    int climbStairs(int n) {
        vector<int> dp(n + 1, 0);
        dp[0] = 1;
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= m; j++) { // 把m换成2，就可以AC爬楼梯这道题
                if (i - j >= 0) dp[i] += dp[i - j];
            }
        }
        return dp[n];
    }
};
```
代码中m表示最多可以爬m个台阶。

**以上代码不能运行哈，我主要是为了体现只要把m换成2，粘过去，就可以AC爬楼梯这道题，不信你就粘一下试试，哈哈**。

**此时我就发现一个绝佳的大厂面试题**，第一道题就是单纯的爬楼梯，然后看候选人的代码实现，如果把dp[0]的定义成1了，就可以发难了，为什么dp[0]一定要初始化为1，此时可能候选人就要强行给dp[0]应该是1找各种理由。那这就是一个考察点了，对dp[i]的定义理解的不深入。

我在[通过一道面试题目，讲一讲递归算法的时间复杂度！](https://programmercarl.com/%E5%89%8D%E5%BA%8F/%E9%80%9A%E8%BF%87%E4%B8%80%E9%81%93%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE%EF%BC%8C%E8%AE%B2%E4%B8%80%E8%AE%B2%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%EF%BC%81.html)[](https://programmercarl.com/%E5%89%8D%E5%BA%8F/%E9%80%9A%E8%BF%87%E4%B8%80%E9%81%93%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE%EF%BC%8C%E8%AE%B2%E4%B8%80%E8%AE%B2%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%EF%BC%81.html)
中，以我自己面试别人的真实经历，通过求x的n次方 这么简单的题目，就可以考察候选人对算法性能以及递归的理解深度，录友们可以看看，绝对有收获！


# 5 参考资料
[代码随想录](https://www.programmercarl.com/0070.%E7%88%AC%E6%A5%BC%E6%A2%AF.html#%E6%80%9D%E8%B7%AF)
自用跳转链接：🈚
