---
title: 4.使用最小花费爬楼梯
date: '2022-07-05 21:03'
categories:
  - "\U0001F468\U0001F3FB‍\U0001F4BBcode"
  - 数据结构与算法
  - 代码随想录
  - 动态规划
index_img: 'https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202207051328142.jpg'
banner_img: 'https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202207051328142.jpg'
tags:
  - 动态规划
---

文章简介：LeetCode  题解—— 746. 使用最小花费爬楼梯
<!-- more -->

# 1 使用最小花费爬楼梯

[力扣题目链接](https://leetcode.cn/problems/min-cost-climbing-stairs/)

数组的每个下标作为一个阶梯，第 i 个阶梯对应着一个非负数的体力花费值 cost[i]（下标从 0 开始）。

**每当你爬上一个阶梯你都要花费对应的体力值，一旦支付了相应的体力值，你就可以选择向上爬一个阶梯或者爬两个阶梯。**

请你找出达到楼层顶部的最低花费。在开始时，你可以选择从下标为 0 或 1 的元素作为初始阶梯。

示例 1：

输入：cost = [10, 15, 20] 输出：15 解释：最低花费是从 cost[1] 开始，然后走两步即可到阶梯顶，一共花费 15 。  示例 2：
 >第一次不要钱，爬上了15，支付15后可以爬一层到楼顶，那我从10开始支付10爬两层不是更好吗
 
输入：cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1] 输出：6 解释：最低花费方式是从 cost[0] 开始，逐个经过那些 1 ，跳过 cost[3] ，一共花费 6 。

提示：

-   cost 的长度范围是 [2, 1000]。
-   cost[i] 将会是一个整型数据，范围为 [0, 999] 。



# 2 思路


**注意题目描述：每当你爬上一个阶梯你都要花费对应的体力值，一旦支付了相应的体力值，你就可以选择向上爬一个阶梯或者爬两个阶梯**

动归五部曲

<font color=#F36208>1.  确定dp数组以及下标的含义</font>
**dp[i]的定义：到达第i个台阶所花费的最
少体力为dp[i]**。
注意这里认为是第一步一定是要花费：
	dp[0] = cost[0];
	dp[1] = cost[1];
	**dp[2] = min(dp[0], dp[1]) + cost[2];**
<font color=#F36208>2.  确定递推公式</font>
**可以有两个途径得到dp[i]，一个是dp[i-1] 一个是dp[i-2]**。
>一旦支付当前下边相应的体力值，就可向上爬一个或者两个楼梯

**dp[i] = min(dp[i - 1], dp[i - 2]) + cost[i];**
爬上台阶i，可能是从 i - 1 层，i-2层爬上来的，然后在离开台阶i 又在需要花费cost[i]
<font color=#F36208>3. dp数组初始化</font>
题目说：可以选择从下标为 0 或 1 的元素作为初始阶梯。
从下标0处离开需要cost[0]，下标1同理
```cpp
vector<int> dp(cost.size());
dp[0] = cost[0];
dp[1] = cost[1];
```
<font color=#F36208>4. 遍历顺序</font>
因为是模拟台阶，而且dp[i]又dp[i-1]dp[i-2]推出，所以是从前到后遍历cost数组就可以了。
**但是稍稍有点难度的动态规划，其遍历顺序并不容易确定下来**。
<font color=#F36208>5. 举例推导dp数组</font>
| cost  | 10  | 15  | 20  |
| ----- | --- | --- | --- |
| dp[i] | 10  | 15  | 30  |
|       |     |     |     |
![746.使用最小花费爬楼梯](https://img-blog.csdnimg.cn/2021010621363669.png)
为什么选择最后两位的最小值呢
?
最后两位支付该值都可以到下一层，假设所求是第N层的最小开销，只需要计算min(谁能到N层)，到了N层后又不到下一层，所以相当于最后一步不用花费，就停止到那了，不用+cost[i]

# 3 代码
编译已通过
```cpp
class Solution {
public:
    int minCostClimbingStairs(vector<int>& cost) {
        vector<int> dp(cost.size());
        dp[0] = cost[0];
        dp[1] = cost[1];
        for(int i = 2; i < cost.size(); i++){// 这里不用<=，因为下标从0开始，取不到cost.size()||从第三个元素开始，下标是2
            dp[i] = min(dp[i - 1], dp[i - 2]) + cost[i];
        }
        return min(dp[cost.size()-1], dp[cost.size() - 2]);

    }
};
```


# 4 参考资料
[代码随想录](https://www.programmercarl.com/0746.%E4%BD%BF%E7%94%A8%E6%9C%80%E5%B0%8F%E8%8A%B1%E8%B4%B9%E7%88%AC%E6%A5%BC%E6%A2%AF.html#%E6%80%9D%E8%B7%AF)
[Leetcode-746.使用最小花费爬楼梯_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1fq4y1T7Uo?spm_id_from=333.337.search-card.all.click&vd_source=f2340d96e99780a96b50d8096ffaaf1a)
自用跳转链接：🈚
