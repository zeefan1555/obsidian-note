---
title: 6.不同路径
date: '2022-07-06 16:34'
categories:
  - "\U0001F468\U0001F3FB‍\U0001F4BBcode"
  - 数据结构与算法
  - 代码随想录
  - 动态规划
index_img: https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202207061640602.jpg
banner_img: https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202207061640602.jpg
tags:
  - 动态规划
---

文章简介：LeetCode  题解——62.不同路径
<!-- more -->

# 1 62.不同路径

[力扣题目链接](https://leetcode.cn/problems/unique-paths/)


一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。

机器人每次只能**向下或者向右**移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。

问总共有多少条不同的路径？

示例 1：

![](https://img-blog.csdnimg.cn/20210110174033215.png)

-   输入：m = 3, n = 7
-   输出：28

示例 2：

-   输入：m = 2, n = 3
-   输出：3

解释： 从左上角开始，总共有 3 条路径可以到达右下角。

1.  向右 -> 向右 -> 向下
2.  向右 -> 向下 -> 向右
3.  向下 -> 向右 -> 向右

示例 3：

-   输入：m = 7, n = 3
-   输出：28

示例 4：

-   输入：m = 3, n = 3
-   输出：6

提示：

-   1 <= m, n <= 100
-   题目数据保证答案小于等于 2 * 10^9

# 2 思路
## 2.1 图论
暂定
## 2.2 数论
暂定

## 2.3 动态规划

m✖️n：行✖️列
按照动规五部曲来分析：

1. 确定dp数组（dp table）以及下标的含义
`dp[i][j]` ：表示从（0 ，0）出发，到(i, j) 有`dp[i][j]`条不同的路径。
2. 确定递推公式
机器人只能向下或向右移动
所以`dp[i][j]`，只能有两个方向来推导出来，即`dp[i - 1][j]` 和 `dp[i][j - 1]`。(上面，左面)
`dp[i][j] = dp[i - 1][j] + dp[i][j - 1]`，因为只能从上面或者左面过来
3.  dp数组的初始化
如何初始化呢，首先`dp[i][0]`一定都是1，因为从(0, 0)的位置到(i, 0)的路径只有一条，那么`dp[0][j]`也同理。
所以初始化代码为：
```
for (int i = 0; i < m; i++) dp[i][0] = 1;
for (int j = 0; j < n; j++) dp[0][j] = 1;
```
4.  确定遍历顺序
这里要看一下递归公式`dp[i][j] = dp[i - 1][j] + dp[i][j - 1]`，`dp[i][j]`都是从其上方和左方推导而来，那么从左到右一层一层遍历就可以了。两个for循环嵌套

这样就可以保证推导`dp[i][j]`的时候，`dp[i - 1][j]` 和 `dp[i][j - 1]`一定是有数值的。

5.  举例推导dp数组

如图所示：
`dp[i][j] = dp[i - 1][j] + dp[i][j - 1]`，`dp[2][2] = dp[1][2] + dp[2][1]`，`dp[3][7] = dp[2][7] + dp[3][6]` 上面/左面
![62.不同路径1](https://img-blog.csdnimg.cn/20201209113631392.png)
# 3 代码
## 3.1 二维数组解法，编译已通过
```cpp
class Solution {
public:
    int uniquePaths(int m, int n) {
      vector<vector<int>> dp(m, vector<int>(n,0));
      for(int i = 0; i < m; i++) dp[i][0] = 1;
      for(int j = 0; j < n; j++) dp[0][j] = 1;
      for(int i = 1; i < m; i++){ // 从(1,1)开始的
          for (int j = 1; j < n; j++){
              dp[i][j] = dp[i-1][j] + dp[i][j-1];
          }
      }
      return dp[m-1][n-1];// 因为下标从0开始，所以-1
    }
};
```
## 3.2 一维数组暂定
# 4 参考资料

自用跳转链接：🈚

