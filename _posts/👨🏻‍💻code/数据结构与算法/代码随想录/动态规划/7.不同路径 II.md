---
title: 7.不同路径 II
date: '2022-07-06 17:26'
categories:
  - "\U0001F468\U0001F3FB‍\U0001F4BBcode"
  - 数据结构与算法
  - 代码随想录
  - 动态规划
index_img: 'https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202207061640602.jpg'
banner_img: 'https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202207061640602.jpg'
tags:
  - 动态规划
---

文章简介：LeetCode  题解——63. 不同路径 II
<!-- more -->

# 1 63.不同路径 II

[力扣题目链接](https://leetcode.cn/problems/unique-paths-ii/)

一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。

机器人每次**只能向下或者向右移动一步**。机器人试图达到网格的右下角（在下图中标记为“Finish”）。

现在考虑**网格中有障碍物**。那么从左上角到右下角将会有多少条不同的路径？

![](https://img-blog.csdnimg.cn/20210111204901338.png)

**网格中的障碍物和空位置分别用 1 和 0 来表示。**

示例 1：

![](https://img-blog.csdnimg.cn/20210111204939971.png)

-   输入：obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]]
-   输出：2 解释：
-   3x3 网格的正中间有一个障碍物。
-   从左上角到右下角一共有 2 条不同的路径：
    1.  向右 -> 向右 -> 向下 -> 向下
    2.  向下 -> 向下 -> 向右 -> 向右

示例 2：

![](https://img-blog.csdnimg.cn/20210111205857918.png)

-   输入：obstacleGrid = [[0,1],[0,0]]
-   输出：1

提示：

-   m == obstacleGrid.length
-   n == obstacleGrid[i].length
-   1 <= m, n <= 100
-   obstacleGrid[i][j] 为 0 或 1


# 2 思路
相比[[6.不同路径]]不同的是多了障碍，遇到障碍`dp[i][j]`保持0就可以了：表示过不去

两个地方需要跳过赋值
1. 初始值(第一行第一列)，跳过有障碍的地方在赋值
2. 递推公式中(除了第一行第一列的)，跳过有障碍的地方在赋值

# 3 代码
编译已通过
```cpp
class Solution {
public:
    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {
        int m = obstacleGrid.size();
        int n = obstacleGrid[0].size();
        vector<vector<int>> dp(m,vector<int>(n,0));
        for(int i = 0; i < m && obstacleGrid[i][0] == 0; i++) dp[0][i] = 1;
        for(int j = 0; j < n && obstacleGrid[0][j] == 0; j++) dp[j][0] = 1;
        for (int i = 1; i < m; i++){
            for(int j = 1; j < n; j++){
                if(obstacleGrid[i][j] == 0){ // if (obstacleGrid[i][j] == 1) continue;
                    dp[i][j] = dp[i-1][j] + dp[i][j-1];
                }
            }
        }
        return dp[m-1][n-1];

    }
};
```


# 4 参考资料

自用跳转链接：🈚

