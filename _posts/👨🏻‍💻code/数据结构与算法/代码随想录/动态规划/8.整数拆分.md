---
title: 8.整数拆分
date: '2022-07-06 21:06'
categories:
  - "\U0001F468\U0001F3FB‍\U0001F4BBcode"
  - 数据结构与算法
  - 代码随想录
  - 动态规划
index_img: 'https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202207061640602.jpg'
banner_img: 'https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202207061640602.jpg'
tags:
  - 动态规划
---

文章简介：LeetCode  题解—— 343. 整数拆分
<!-- more -->

# 1 整数拆分

[力扣题目链接](https://leetcode.cn/problems/integer-break/)

给定一个正整数 n，将其拆分为至少两个正整数的和，并使这些整数的乘积最大化。 返回你可以获得的最大乘积。

示例 1:

-   输入: 2
-   输出: 1
-   解释: 2 = 1 + 1, 1 × 1 = 1。

示例 2:

-   输入: 10
-   输出: 36
-   解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36。
-   说明: 你可以假设 n 不小于 2 且不大于 58。

# 2 思路
## 2.1 动态规划
将数的拆分想象成块的切分
2,3不切分，因为切分来会变小
如果不用去写dp初始值，可以在转移方程里面再加上一个和j * i-j的最大值比较
两个for循环是标准的动归写法

1. 确定dp数组（dp table）以及下标的含义
dp[i]：分拆数字i，可以得到的最大乘积为dp[i]。
2. 确定递推公式
下面这样写需要提前定义2,3不可拆定义出来他们的dp值，因为他俩不用拆是最大
dp[i] = max({dp[i],dp[j] * dp[i-j] );
dp[i]是随着i的值在一直变化的，max 中有dp[i]就是保证，不断变化中的值取最高的那一个
j是切的位置，把一个数切成两部分，而这左右两部分又可以在切。也就是dp[j]，dp[i-j]，也是默认将一个数强制拆成4份以及4份以上了。

或者这样，不用提前定义dp[2]，dp[3]
dp[i] = max(dp[i], max((i - j) * j, dp[i - j] * j));
3. dp的初始化
dp[0] dp[1]无意义，没法拆，所以不赋值。从dp[2] = 1开始，把dp[3] = 2。
2，3不用拆是最大的


## 2.2 贪心算法
数学已证明过：**每次拆成n个3，如果剩下是4，则保留4，然后相乘**
尽量切3，最后切2，2和3是最稳定最稳定不可拆分质数
>1，2，3不划分最大，一划分反而变小了
# 3 代码
## 3.1 动态规划
编译已通过
```cpp
class Solution {
public:
    int integerBreak(int n) {
        vector<int> dp(n+1,0);
        if (n == 2) return 1;
        if (n == 3) return 2;
        dp[2] = 1;
        dp[3] = 2;
        for (int i = 4; i <= n; i++){ // 应该从数字4开始，对应的下标是5 
            for (int j = 1; j <= i/2; j++){ // 切一半就行，另一半是对称的
                dp[i] = max(dp[i], max(j*(i-j), j*dp[i-j])); // 后一个max中是数的相乘 和 数和上一次的最优结果相乘
            }
        }
        return dp[n];
    }
};
```
编译未通过
```cpp
class Solution {
public:
    int integerBreak(int n) {
        vector<int> dp(n+1);
        if (n == 2) return 1;
        if (n == 3) return 2;
        dp[2] = 1;
        dp[3] = 2;
        for (int i = 4; i <= n; i++){
            for (int j = 1; j <= i/2; j++){
                dp[i] = max(dp[i], dp[j]*dp[i-j]);
            }
        }
        return dp[n];
    }
};
```
![](https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202207112130227.png)
// 错了的原因是dp[1]是0，必须定义dp[1] = 1,另外还有其他的原因

## 3.2 贪心
编译已通过
```cpp
class Solution {
public:
    int integerBreak(int n) {
        if (n == 2) return 1;
        if (n == 3) return 2;
        if (n == 4) return 4; // 要有 = 4的判断，不然4的没法输出
                int result = 1;，
        while(n > 4){
            result *= 3;
            n -= 3;
        }
        return result * n;
    }
};
```


![](https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202207112032423.png)

# 4 参考资料
[LeetCode每日打卡.343.整数拆分_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1Nt4y1D7gh?spm_id_from=333.337.search-card.all.click&vd_source=f2340d96e99780a96b50d8096ffaaf1a)
自用跳转链接：🈚
