---
id: ae2b0ee3-99ee-4a44-906e-5a2a66bf5f40
title: 17.用最少数量的箭引爆气球
date: '2022-06-10 10:00'
categories:
  - "\U0001F468\U0001F3FB‍\U0001F4BBcode"
  - 数据结构与算法
  - 代码随想录
  - 贪心算法
tags:
  - 贪心算法
banner_img: 'https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202206200917436.jpg'
---
**文章简介**：
	力扣题解：452用最少数量的箭引爆气球
<!-- more -->

# 1 452用最少数量的箭引爆气球

[力扣题目链接](https://leetcode-cn.com/problems/minimum-number-of-arrows-to-burst-balloons/)


在二维空间中有许多球形的气球。对于每个气球，提供的输入是水平方向上，气球直径的开始和结束坐标。由于它是水平的，所以纵坐标并不重要，因此只要知道开始和结束的横坐标就足够了。开始坐标总是小于结束坐标。

一支弓箭可以沿着 x 轴从不同点完全垂直地射出。在坐标 x 处射出一支箭，若有一个气球的直径的开始和结束坐标为 xstart，xend， 且满足  xstart ≤ x ≤ xend，则该气球会被引爆。可以射出的弓箭的数量没有限制。 弓箭一旦被射出之后，可以无限地前进。我们想找到使得所有气球全部被引爆，所需的弓箭的最小数量。

给你一个数组 points ，其中 points [i] = [xstart,xend] ，**返回引爆所有气球所必须射出的最小弓箭数。**

示例 1：

-   输入：points = [ [10,16],[2,8],[1,6],[7,12] ]
-   输出：2
-   解释：对于该样例，x = 6 可以射爆 [2,8],[1,6] 两个气球，以及 x = 11 射爆另外两个气球

示例 2：

-   输入：points = [ [1,2],[3,4],[5,6],[7,8] ]
-   输出：4

示例 3：

-   输入：points = [ [1,2],[2,3],[3,4],[4,5] ]
-   输出：2

示例 4：

-   输入：points = [ [1,2] ]
-   输出：1

示例 5：

-   输入：points = [ [2,3],[2,3] ]
-   输出：1

提示：

-   0 <= points.length <= 10^4
-   points[i].length == 2
-   -2^31 <= xstart < xend <= 2^31 - 1


# 2 思路
## 2.1 b站参考视频及笔记
[看了三天动画，我拿到阿里研发offer，贪心算法，射击气球 LeetCode 452_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV12y4y1k7B5/?spm_id_from=333.788.recommend_more_video.1&vd_source=f2340d96e99780a96b50d8096ffaaf1a)
![](https://s1.vika.cn/space/2022/06/10/3141cfabb0c94275b7edf999b4b5197f)

从这里开始看即可

[09:04](https://www.bilibili.com/video/BV12y4y1k7B5/?spm_id_from=333.788.recommend_more_video.1&vd_source=f2340d96e99780a96b50d8096ffaaf1a#t=544.080526)

先按左端点先排好序
不用管左端点，**只关心右端点就行**，因为只在右端点射击就行了
记录射击区间为第一个数组区间：[一左，一右]，**其实只关心右端点就行了**



如果第二个数组的**左端点**==小于==第一个数组的**右端点**(两个数组有重叠部分)
说明第二个数组在射击区间内，同时将射击区间更新为：[二左，一右] (重叠部分)，右端点无变化

[10:17](https://www.bilibili.com/video/BV12y4y1k7B5/?spm_id_from=333.788.recommend_more_video.1&vd_source=f2340d96e99780a96b50d8096ffaaf1a#t=617.733348)
如果第二数组的右端点==小于==第一个数组的右端点 (说明要缩小射击区间)
射击区间为：[一左，二右]

  
如果第二数组的左端点大于第一个数组的**右端点**(两个数组**没有**重叠部分)，箭数+1(需要另一支箭才可以射完)
更新射击区间为：[二左，二右] (第二个数组区间)


[12:45代码结果](https://www.bilibili.com/video/BV12y4y1k7B5/?spm_id_from=333.788.recommend_more_video.1&vd_source=f2340d96e99780a96b50d8096ffaaf1a#t=765.508572)






## 2.2 代码随想录
**局部最优**：当气球出现重叠，一起射，所用弓箭最少。

**全局最优**：把所有气球射爆所用弓箭最少。
>按照气球的起始位置排序，从前向后遍历气球数组，靠左尽可能让气球重复，重复的用一个箭射

**如果气球重叠了，重叠气球中最小右边界， 之前的区间一定需要一个弓箭**

可以看出首先第一组重叠气球，一定是需要一个箭， 
气球3的**左边界大于**了第一组重叠气球的**最小右边界**，所以再需要一支箭来射气球3了。
>此时箭数+1

![https://img-blog.csdnimg.cn/20201123101929791.png](https://img-blog.csdnimg.cn/20201123101929791.png)

```cpp
class Solution {

private:

    static bool cmp(const vector<int>& a, const vector<int>& b) {

        return a[0] < b[0];

    }

public:

    int findMinArrowShots(vector<vector<int>>& points) {

        if (points.size() == 0) return 0;

        sort(points.begin(), points.end(), cmp);

        int result = 1; // points 不为空至少需要一支箭

        for (int i = 1; i < points.size(); i++) {

            if (points[i][0] > points[i - 1][1]) {  // 气球i和气球i-1不挨着，注意这里不是>=
			//points: {{1, 6}, {2, 8}, {7, 12}, {10, 16}} if (points[i][0] > points[i - 1][1])
			//eg：points[1][0] > points[0][1]：第二个元素的第0号位置 >第一个元素的第1号位置 2>6 (if 语句跳过)看图更容易懂
                result++; // 需要一支箭

            }

            else {  // 气球i和气球i-1挨着

                points[i][1] = min(points[i - 1][1], points[i][1]); // 更新重叠气球最小右边界

            }

        }

        return result;

    }

};

```






# 3 代码
图解
![|700](https://s1.vika.cn/space/2022/06/10/a494349688e74c7ebe4ce80e4b26d1bc)




## 3.1 自写编译已通过(b站三天动画版)
```cpp
class Solution {
private:
static bool cmp (const vector<int>& a, const vector<int>& b){
    return a[0] < b[0];// 从小到大排序
}

public:
    int findMinArrowShots(vector<vector<int>>& points) {
        if(points.size() == 0) return 0;
        sort(points.begin(), points.end(), cmp);
        int arrow = 1;
        int rarrow = points[0][1]; // 射击区间的右端点
        for (int i = 1; i < points.size(); i++){
            if (points[i][0] <= rarrow){ // 有重叠部分，这里必须小于等于因为也要找到挨着但不重叠的，最后是用射击右端点来判别的
                if(points[i][1] < rarrow){ // 如果第二数组的右端点比第一个数组的右端点小，就缩小射击区间
                rarrow = points[i][1]; // 更新右端点
                }
            }
            else {
                rarrow = points[i][1];
                arrow ++;
            }
        }
        return arrow;

    }
};
```

## 3.2 自写编译已通过(carl) 推荐

```cpp
class Solution {
private:
static bool cmp (const vector<int>& a, const vector<int>& b){
    return a[0] < b[0];// 从小到大排序
}

public:
    int findMinArrowShots(vector<vector<int>>& points) {
        if(points.size() == 0) return 0;
        sort(points.begin(), points.end(), cmp);
        int arrow = 1;// 有气球至少需要一个箭
        for(int i = 1; i < points.size(); i++){
        // 如果有重叠或者挨着就可以用一支箭射爆(因为射爆的区间是大区间，重叠的是子区间),右边界就是射爆的位置
            if (points[i][0] <= points[i-1][1]){// 2的左边界比1的右边界小说明重叠了
                    points[i][1] = min (points[i-1][1],points[i][1]); // 更新右边界与(变成重叠区间)，与下一个比,看下一个的位置是否在重叠区间内，不在则需要另外的箭
                }

            else arrow++;
            } 


            return arrow;
            
        }
   
};
```



# 4 参考资料
[代码随想录](https://www.programmercarl.com/0452.%E7%94%A8%E6%9C%80%E5%B0%91%E6%95%B0%E9%87%8F%E7%9A%84%E7%AE%AD%E5%BC%95%E7%88%86%E6%B0%94%E7%90%83.html)
[看了三天动画，我拿到阿里研发offer，贪心算法，射击气球 LeetCode 452_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV12y4y1k7B5/?spm_id_from=333.788.recommend_more_video.1&vd_source=f2340d96e99780a96b50d8096ffaaf1a)
自用跳转链接：[ob](obsidian://advanced-uri?vault=Documents&uid=ae2b0ee3-99ee-4a44-906e-5a2a66bf5f40)，[blog](http://localhost:4000/2022/06/10/17.yong-zui-shao-shu-liang-de-jian-yin-bao-qi-qiu/)


