---
id: 13b04b05-d8f9-4a57-a909-3b6b3af97825
title: 19.划分字母区间
date: '2022-06-15 09:21'
categories:
  - "\U0001F468\U0001F3FB‍\U0001F4BBcode"
  - 数据结构与算法
  - 代码随想录
  - 贪心算法
tags:
  - 贪心算法
---

文章简介
	力扣题解：763.划分字母区间
<!-- more -->

# 1 763.划分字母区间

[力扣题目链接](https://leetcode-cn.com/problems/partition-labels/)

字符串 S 由小写字母组成。我们要把这个字符串划分为尽可能多的片段，同一字母最多出现在一个片段中。返回一个表示每个字符串片段的长度的列表。

示例：

-   输入：S = "ababcbacadefegdehijhklij"
-   输出：[9,7,8] 解释： 划分结果为 "ababcbaca", "defegde", "hijhklij"。 每个字母最多出现在一个片段中。 像 "ababcbacadefegde", "hijhklij" 的划分是错误的，因为划分的片段数较少。

提示：

-   S的长度在[1, 500]之间。
-   S只包含小写字母 'a' 到 'z' 。

# 2 思路

总共分为两步：

-   统计每一个字符最后出现的位置
-   从头遍历字符，并更新字符的最远出现下标，如果找到字符最远出现位置下标和当前下标相等了，则找到了分割点
![763.划分字母区间|900](https://img-blog.csdnimg.cn/20201222191924417.png)
# 3 代码
## 3.1 carl断点调试
[19.划分字母区间(carl).MP4](file:///Users/yibeikongqiu/Desktop/ishot视频/贪心算法/19.划分字母区间(carl).mp4)
	以后可以监听几个变量：S[i]，right - left +1
	[[c++中 - ‘0’ 以及 -'a' 的相减操作解释]]
	S = "**a**babcbac**a**defegdehijhklij"
	[00:12](file:///Users/yibeikongqiu/Desktop/ishot%E8%A7%86%E9%A2%91/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/19.%E5%88%92%E5%88%86%E5%AD%97%E6%AF%8D%E5%8C%BA%E9%97%B4(carl).mp4#t=12.709769) 
		S = "a==b==abcbacadefegdehijhklij"，相当于将b对应1，这个数存在了hash里
		hash[S[1] - 'a'] = 1，即hash[2] = 1
	[01:03](file:///Users/yibeikongqiu/Desktop/ishot%E8%A7%86%E9%A2%91/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/19.%E5%88%92%E5%88%86%E5%AD%97%E6%AF%8D%E5%8C%BA%E9%97%B4(carl).mp4#t=63.222835) 
		S = "==**a**==babcbac==**a**==defegdehijhklij"
		将每一个字母的所对应的下标值放到了hash数组里了，相同字母的是更新的，因为 S[1] - 'a'= S[9] - 'a' = 0 (第一个区间)
	[01:10](file:///Users/yibeikongqiu/Desktop/ishot%E8%A7%86%E9%A2%91/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/19.%E5%88%92%E5%88%86%E5%AD%97%E6%AF%8D%E5%8C%BA%E9%97%B4(carl).mp4#t=70.392045) 
		此使 right = max(0, 8)，之道i 到下标8才会进入if 循环语句，它在下标8之前一直在比较有没有比8更大值，有的话说明第一个分割点更远
	[01:53](file:///Users/yibeikongqiu/Desktop/ishot%E8%A7%86%E9%A2%91/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/19.%E5%88%92%E5%88%86%E5%AD%97%E6%AF%8D%E5%8C%BA%E9%97%B4(carl).mp4#t=113.069755)
		到达第一分割点下标8(i = 8)处，开始push_back结果，并且更新下一个区间
		right  - left + 1  = 8-0+1= 9 第一个区间相当于：尾 - 头 + 1
		下个区间要在更新一下头即left = i+1 = 9
		
	






### 3.1.1 代码

自写 编译已通过
```cpp
class Solution {
public:
    vector<int> partitionLabels(string S) {
       int hash[27] = {0};// 数组初始化必须是列表，不能是单纯的0
       //int hash[S.size()] = {0}; // S.size 可变动的，错误：可变大小的对象可能未初始化

       //hash数组中写入每个字母的所对应的最远下标值
       //因每个字母的S[i] - 'a'是不变的，所以可以一直更新最远下标
       for (int i = 0; i < S.size(); i++){
           hash[S[i] - 'a'] = i;
       }
       int right = 0;
       int left = 0;
       vector<int> result; // vector 能够不断往里加数据
       // 不断的找分割区间
       for (int i = 0; i < S.size(); i++){
           right = max (right, hash[S[i] - 'a']); // 确定区间的尾部 不是hash[i], 是每个字母对应的最远下标
           if(i == right){
               result.push_back(right - left +1); // 返回是字符串的长度所以+1
               left = i + 1; // 更新下一个区间头部，现在i是上一区间的尾，所以下个头部为 i+1
           }
       }
       return result;
    }
};
```





# 4 参考资料

[代码随想录](https://www.programmercarl.com/0763.%E5%88%92%E5%88%86%E5%AD%97%E6%AF%8D%E5%8C%BA%E9%97%B4.html#%E6%80%9D%E8%B7%AF)
自用跳转链接：[ob](obsidian://advanced-uri?vault=Documents&uid=13b04b05-d8f9-4a57-a909-3b6b3af97825)，[blog](http://localhost:4000/2022/06/15/19.hua-fen-zi-mu-qu-jian/)



