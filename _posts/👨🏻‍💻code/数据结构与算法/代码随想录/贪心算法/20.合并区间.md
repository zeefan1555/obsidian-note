---
id: 88f96891-7092-4c04-a067-349995d05800
title: 20.合并区间
date: '2022-06-16 10:17'
categories:
  - "\U0001F468\U0001F3FB‍\U0001F4BBcode"
  - 数据结构与算法
  - 代码随想录
  - 贪心算法
tags:
  - 贪心算法
banner_img: 'https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202206200917436.jpg'
---

文章简介
	力扣题解： 56. 合并区间
<!-- more -->



# 1 56. 合并区间

[力扣题目链接](https://leetcode-cn.com/problems/merge-intervals/)

给出一个区间的集合，请合并所有重叠的区间。

示例 1:

-   输入: intervals = [ [1,3],[2,6],[8,10],[15,18] ]
-   输出: [ [1,6],[8,10],[15,18] ]
-   解释: 区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].

示例 2:

-   输入: intervals = [ [1,4],[4,5] ]
-   输出: [ [1,5] ]
-   解释: 区间 [1,4] 和 [4,5] 可被视为重叠区间。
-   注意：输入类型已于2019年4月15日更改。 请重置默认代码定义以获取新方法签名。

提示：

-   intervals[ i ]  [0] <= intervals[ i ]  [ 1 ]

# 2 思路

左边界排序后
局部最优：每次合并都取**最大的右边界**，这样就可以合并更多的区间了
整体最优：合并所有重叠的区间。
排序后：intervals[i]的左边界在intervals[i - 1]左边界和右边界的范围内，一定有重叠(包含或者交集)！
>第二个数组的头如果小于第一个数组的尾，那么一定有重复
![56.合并区间](https://img-blog.csdnimg.cn/20201223200632791.png)



## 2.1 排序
按左边界排序
```cpp
static bool cmp (const vector<int>& a, const vector<int>& b) {
        return a[0] < b[0];
    }
```

## 2.2 判断是否重叠 +合并区间
### 2.2.1 是否重叠
for循环中判断重叠
第二个数组的头小于第一个数组的尾即为重叠
`intervals[i][0] <= intervals[i - 1][1]`
定义出来两个数组的头和尾，这样下边写的更简洁
```cpp
// 下标从1开始，因为要比较：intervals[i][0] <= intervals[i - 1][1]
int start = intervals[i - 1][0]; // 初始区间的左边界
int end = intervals[i - 1][1];   // 初始区间的右边界
```
### 2.2.2 合并区间
用[[while 循环]]合并区间：while循环是if 和 for 循环的结合体
比较第一个数组和第二数组的尾部谁更大，更新数组的尾部就行
同时要控制i的增加，如果合并了，那么进行一次i++, 出去while 循环后，for又进行一次i++，这样就控制了跳过了合并区间👉🏻[[20.合并区间#^hcnuf7]]
```cpp
int end = intervals[i - 1][1];
end = max(end, intervals[i][1]); // 比较第一个数组和第二数组的尾部
```
整体代码
```cpp
  for (int i = 1; i < length; i++) { // 判断重叠
            int start = intervals[i - 1][0];    // 初始为i-1区间的左边界
            int end = intervals[i - 1][1];      // 初始i-1区间的右边界
            while (i < length && intervals[i][0] <= end) { // 合并区间
                end = max(end, intervals[i][1]);    // 不断更新右区间
                if (i == length - 1) flag = true;   // 最后一个区间也合并了
                i++;                                // 继续合并下一个区间
            }
```




## 2.3 放入result结果集
取合并区间的头和尾作为一个新的数组加入到result数组中，`result.push_back({start, end});`
如果没有合并就把原数组加入result

**注意**：
还要单独判断最后一个数组是否合并了，如果合并了，正常加入就如result就行
如果没合并要单独的把最后一个数组加入result


# 3 代码
## 3.1 代码随想录断点调试
carl
[20.合并区间(carl).mp4](file:///Users/yibeikongqiu/Desktop/ishot视频/贪心算法/20.合并区间(carl).mp4)
	[00:19](file:///Users/yibeikongqiu/Desktop/ishot%E8%A7%86%E9%A2%91/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/20.%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4(carl).mp4#t=19.133532) ：i++
		如果合并了第二区间，那么自然i不能从第二个区间在开始，要从第三个位置开始，while循环中有个i++，到了for循环中还有个i++, i到时候等于3，就跳过了合并的区间在开始
	[00:29](file:///Users/yibeikongqiu/Desktop/ishot%E8%A7%86%E9%A2%91/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/20.%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4(carl).mp4#t=29.228653)：此时i 等于3，从合并区间的下个区间在开始进行 ^hcnuf7





## 3.2 carl 自写
编译通过

```cpp
class Solution {
public:
    static bool cmp (const vector<int>& a, const vector<int>& b){
        return a[0] < b[0];// 只比较左位置，所以不用二维数组
    }

        vector<vector<int>> result;
        vector<vector<int>> merge(vector<vector<int>>& intervals) {
        if(intervals.size() == 0) return result;// 此时result为空
        int length = intervals.size();
        bool flag = false; // 不要定义在for循环中

        for (int i = 1; i < length; i++){
            int start = intervals[i - 1][0];
            int end = intervals[i - 1][1];
            while (i < length && intervals[i][0] <= end){ // 不要忘记=，“=”是头尾相等
                end = max(end, intervals[i][1]);
                if (i == length - 1) flag = true;
                i++;
            }
            result.push_back ({start,end}); // 如果没合并就是单独的，如果合并了也更新了。
                                            // 每一次的循环都在加入result数组，所以在for循环中
        }
        if(flag == false) {
            result.push_back({intervals[length-1][0],intervals[length-1][1]});
        }
        return result;
    }
};
```




# 4 参考资料
[代码随想录](https://www.programmercarl.com/0056.%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4.html#%E6%80%9D%E8%B7%AF)
<sub>自用跳转链接</sub>：[ob](obsidian://advanced-uri?vault=Documents&uid=88f96891-7092-4c04-a067-349995d05800)，[blog](http://localhost:4000/2022/06/16/20.he-bing-qu-jian/)
