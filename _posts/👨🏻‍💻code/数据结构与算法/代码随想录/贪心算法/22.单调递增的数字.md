---
id: 49dde99d-8015-4224-9c0b-96d9d0dae41a
title: 22.单调递增的数字
date: '2022-07-03 20:57'
categories:
  - "\U0001F468\U0001F3FB‍\U0001F4BBcode"
  - 数据结构与算法
  - 代码随想录
  - 贪心算法
tags:
  - 贪心算法
index_img: 'https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202206240956178.jpg'
banner_img: 'https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202206200917436.jpg'
---

文章简介
	力扣题解： 738.单调递增的数字
<!-- more -->
# 1 738.单调递增的数字

[力扣题目链接](https://leetcode.cn/problems/monotone-increasing-digits/)

给定一个非负整数 N，找出小于或等于 N 的最大的**整数**，同时这个整数需要满足其**各个位数上**的数字是单调递增。

（当且仅当每**个相邻位数上的数字 x 和 y 满足 x <= y** 时，我们称这个整数是单调递增的。）

示例 1:

-   输入: N = 10
-   输出: 9

示例 2:

-   输入: N = 1234
-   输出: 1234

示例 3:

-   输入: N = 332
-   输出: 299

说明: N 是在 [0, 10^9] 范围内的一个整数。


# 2 思路

找≤ N，的最大单增的整数
如果不递增，就把除最后一位每一位都减1，这样保证了减过数比原数小。然后在把除了第一个位(因为第一个位最大不能变，变了会使得比原来的数大)，后边的位数全部令为9，这样就得到了最大的整数。
代码：一旦出现strNum[i - 1] > strNum[i]的情况（非单调递增），首先想让strNum[i - 1]--，然后strNum[i]给为9

例如 
332 → 222→299
753 → 643 → 699

## 2.1 断点调试
 
[22.单调递增的数字(carl:332).mp4](file:///Users/yibeikongqiu/Desktop/ishot视频/贪心算法/22.单调递增的数字(carl).mp4)  
[00:07](file:///Users/yibeikongqiu/Desktop/ishot%E8%A7%86%E9%A2%91/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/22.%E5%8D%95%E8%B0%83%E9%80%92%E5%A2%9E%E7%9A%84%E6%95%B0%E5%AD%97(carl).mp4#t=7.519521) 前一个数大于后一个数则让前一个数减1
>从后往前遍历，for (i = num.size () - 1; i > 0; i--) [[for 循环]]

flag至少是1，因为i 不会取到0。这样就报证了至少从第二个2数开始赋9，直到到最后一个数


[00:10](file:///Users/yibeikongqiu/Desktop/ishot%E8%A7%86%E9%A2%91/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/22.%E5%8D%95%E8%B0%83%E9%80%92%E5%A2%9E%E7%9A%84%E6%95%B0%E5%AD%97(carl).mp4#t=10.337641) 只需要减1的原因是：让他的每一个位都比原来的数小，在把除了第一个位(因为第一个位最大)，后边的位数全部令为9，这样就得到了最大的整数


[22.单调递增的数字(carl/1234)](file:///Users/yibeikongqiu/Desktop/ishot视频/贪心算法/22.单调递增的数字(carl:1234).mp4)  
	1234 本身都是递增的，所以第一个for循环会跳过，第二for循环也不会执行


# 3 代码
```cpp
class Solution {
public:
    int monotoneIncreasingDigits(int n) {
        string strNum = to_string(n);
        int flag = strNum.size() ;
        for (int i = strNum.size() - 1; i > 0; i--){
            if (strNum[i - 1]> strNum[i]){
                flag = i;
                strNum[i-1]--;
            }
        }
        for (int i = flag; i < strNum.size(); i++){
            strNum[i] = '9';
        }
        return stoi (strNum);
    }
};
```

stoi函数 #flashcards/代码随想录 
?
将数字字符串转为数字："2147482" → 2147482
<!--SR:!2022-07-07,3,250-->

# 4 参考资料
[代码随想录](https://www.programmercarl.com/0738.%E5%8D%95%E8%B0%83%E9%80%92%E5%A2%9E%E7%9A%84%E6%95%B0%E5%AD%97.html#%E6%9A%B4%E5%8A%9B%E8%A7%A3%E6%B3%95)
自用跳转连接：[ob](obsidian://advanced-uri?vault=Documents&uid=49dde99d-8015-4224-9c0b-96d9d0dae41a)， [blog]()