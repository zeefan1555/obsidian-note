---
title: 23.买卖股票的最佳时机含手续费
date: '2022-07-04 17:04'
categories:
  - "\U0001F468\U0001F3FB‍\U0001F4BBcode"
  - 数据结构与算法
  - 代码随想录
  - 贪心算法
tags:
  - 贪心算法
index_img:  https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202207041948383.jpg
banner_img: https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202207041948383.jpg
---

文章简介
	力扣题解：714. 买卖股票的最佳时机含手续费
<!-- more -->

# 1 买卖股票的最佳时机含手续费

[力扣题目链接](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/)

给定一个整数数组 prices，其中第 i 个元素代表了第 i 天的股票价格 ；非负整数 fee 代表了交易股票的手续费用。

你可以无限次地完成交易，但是你每笔交易都需要付手续费。**如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。**

**返回获得利润的最大值。**

注意：这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续费。
>相当于买入和卖出

示例 1: 输入: prices = [1, 3, 2, 8, 4, 9], fee = 2 输出: 8

解释: 能够达到的最大利润: 在此处买入 prices[0] = 1 在此处卖出 prices[3] = 8 在此处买入 prices[4] = 4 在此处卖出 prices[5] = 9 总利润: ((8 - 1) - 2) + ((9 - 4) - 2) = 8.

注意:

-   0 < prices.length <= 50000.
-   0 < prices[i] < 50000.
-   0 <= fee < 50000.

# 2 思路
## 2.1 [[6. 买卖股票的最佳时机II]]
![[6. 买卖股票的最佳时机II#2 思路]]
与 6的区别是多了个手续费
有了手续费，就要关系什么时候买卖了，因为计算所获得利润，需要考虑买卖利润可能不足以手续费的情况。
用贪心策略，就是最低值买，最高值（减去手续费还盈利）就卖。

找到两个点
-   买入日期：其实很好想，遇到更低点就记录一下。
-   卖出日期：这个就不好算了，但也没有必要算出准确的卖出日期，只要当前价格大于（最低价格+手续费），就可以收获利润，至于准确的卖出日期，就是连续收获利润区间里的最后一天（并不需要计算是具体哪一天）。

做收获利润操作的时候其实有三种情况：
-   情况一：收获利润的这一天并不是收获利润区间里的最后一天（**不是真正的卖出，相当于持有股票**），所以后面要继续收获利润。
-   情况二：前一天是收获利润区间里的最后一天（相当于真正的卖出了），今天要重新记录最小价格了。
-   情况三：不作操作，保持原有状态（买入，卖出，不买不卖）
### 2.1.1 思路总结
1. 不断的寻找最低点，在最低点时买入
2. 寻找有利润的时候买入，更新下一次的买入位置在循环卖出
3. 对所有利润加和

## 2.2 断点调试


[23.买卖股票的最佳时机含手续费](file:///Users/yibeikongqiu/Desktop/ishot视频/贪心算法/23.买卖股票的最佳时机含手续费.mp4)


[00:10](file:///Users/yibeikongqiu/Desktop/ishot%E8%A7%86%E9%A2%91/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/23.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%E5%90%AB%E6%89%8B%E7%BB%AD%E8%B4%B9.mp4#t=10.471542) 情况三：现在的价格不是最低的，并且卖出的话亏本
 
[00:28](file:///Users/yibeikongqiu/Desktop/ishot%E8%A7%86%E9%A2%91/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/23.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%E5%90%AB%E6%89%8B%E7%BB%AD%E8%B4%B9.mp4#t=28.795416) 
#疑问 #已解决 
为什么要minPrice = prices[i]- fee呢，如果去掉了- fee 则结果不对
~~因为在该下标处已经交过了一次手续费，不需要在交了？？？~~

输入：prices = [1,3,7,5,10,3], fee = 3
输出：6
相当于：1时买入，10时卖出(10-1-3 = 6)
并不是：1时买入，7时卖出，5时买入，10时卖出(7-1-3  +  10 - 5 -3 = 5)
minprice = price[i] - fee  有正利润就假装卖了，先收集利润，- fee 的作用是如果后边的还有利润更高的，则这次其实是不卖的
eg：7时有正利润的先收集起来(7-1-3=3)
但此时的minPrice = 7-3  = 4， 4是后边的最小的，接下来的利润是10-4-3= 3 
总利润就是3+3 = 6，而不是像上边计算的5，这个作用就是，看似在7处卖了，实际没卖，最后是在10的位置卖的

# 3 代码
编译已通过
```cpp
class Solution {
public:
    int maxProfit(vector<int>& prices, int fee) {
        int result = 0;
        int minPrice = prices[0];
        for(int i = 1; i < prices.size(); i++){
            if (prices[i] < minPrice) minPrice = prices[i];
            if (prices[i] > minPrice && prices[i] - minPrice - fee < 0) continue;
            if (prices[i] - minPrice - fee > 0){
                result += prices[i] -minPrice - fee;
                minPrice = prices[i] - fee; 
            }
        }
        return result;
    }
};
```


# 4 知识点
[[continue]]


# 5 参考资料
自用跳转连接：[ob]()， [blog]()


