---
title: 3.摆动序列
tags:
  - 代码随想录
  - 贪心算法
published: true
hideInList: false
isTop: false
categories:
  - "\U0001F468\U0001F3FB‍\U0001F4BBcode"
  - 数据结构与算法
  - 代码随想录
  - 贪心算法
date: 2022-05-28 16:57:45
feature:
---
# 1 摆动序列

[力扣题目链接](https://leetcode-cn.com/problems/wiggle-subsequence/)

如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为摆动序列。第一个差（如果存在的话）可能是正数或负数。少于两个元素的序列也是摆动序列。

例如， [1,7,4,9,2,5] 是一个摆动序列，因为差值 (6,-3,5,-7,3) 是正负交替出现的。相反, [1,4,7,2,5] 和 [1,7,4,5,5] 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。

给定一个整数序列，返回作为摆动序列的最长子序列的长度。 通过从原始序列中删除一些（也可以不删除）元素来获得子序列，剩下的元素保持其原始顺序。

示例 1:

-   输入: [1,7,4,9,2,5]
-   输出: 6
-   解释: 整个序列均为摆动序列。

示例 2:

-   输入: [1,17,5,10,13,15,10,5,16,8]
-   输出: 7
-   解释: 这个序列包含几个长度为 7 摆动序列，其中一个可为[1,17,10,13,10,16,8]。

示例 3:

-   输入: [1,2,3,4,5,6,7,8,9]
-   输出: 2
>后一个数减前一个数的值，正负交替


# 2 思路
![](https://s1.vika.cn/space/2022/05/28/1af591dff4b846a3999e21e948dd6e70)

局部最优：变成没有坡度的峰
整体最优：尽可能有最多的**没有坡度的峰**

最左面和最右面的峰值不好统计
可以针对序列[2,5]，可以假设为[2,2,5]，这样它就有坡度了即preDiff = 0


定义变量：
左坡度：preDiff >= 0 或者preDiff <= 0也行，(等于0是最左面的情况)
右坡度：curDiff < 0 或者cur >0,
result：统计百度序列的个数
>反正左坡度和右坡度需要异号，并且左坡度可以 = 0；
>![](https://s1.vika.cn/space/2022/05/28/f1551bf99b894ba08967e7dd87387603)

result初始为1（默认最右面有一个峰值），此时curDiff > 0 && preDiff <= 0，那么result++（计算了左面的峰值），最后得到的result就是2（峰值个数为2即摆动序列长度为2）
>问：这样话直接把result初始为2不行吗？
>	答：要用到前一对和后一对的差值。只有有两个数就可以有这两个差值，所以nums.size() <= 1 即可返回





编译已通过
```cpp
class Solution {
public:
    int wiggleMaxLength(vector<int>& nums) {
        if( nums.size() <= 1 ) return nums.size();// 长度不超过1
        int left = 0;
        int right = 0;
        int result = 1;

        for (int i = 1; i < nums.size() ; i++){ // 这样写更好
            right = nums[i] - nums[i-1];
            if (right > 0 && left <= 0 || right < 0 && left >= 0){ // 两边要异号啊
                result++;
                left = right;
            }
        }
        return result;

    }
};
```



**贪心的题目说简单有的时候就是常识，说难就难在都不知道该怎么用贪心**。
有什么方法想到贪心→多做